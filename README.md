# Go による Clean Architecture の原則を参考に実装したサンプル構成
このアプリケーションは、Goにおいて Clean Architecture の原則を参考に実装したサンプルアプリケーションです。アプリケーションは階層化されたアーキテクチャに従っており、関心事の分離、モジュール性、テスト容易性、および保守性を促進しています。

## アーキテクチャの概要
アプリケーションは以下の層で構成されています。


### １.Domain層
アプリケーションのコアビジネスロジック、エンティティ、およびアプリケーションの契約を定義する箇所。サンプルでは、`entity`と`factory`を実装している。
- entity
  - アプリケーションのコアエンティティを定義した箇所。コアエンティティとは、ドメインの不変条件を維持する箇所。例えば車は空を飛ばないし海を渡らないが陸を走るという振る舞いをするが、エンティティではそのようなドメインの制約やルールを定義する。
- factory
  - ドメインオブジェクト(エンティティ)の生成ロジックを集約し、複雑な生成プロセスを記載する箇所。主にエンティティの生成および依存関係の管理を行う場所。登録系の処理の際には、ファクトリーの複雑なロジックを通過して生成されたエンティティのみが登録へと進むことができる。

#### 参考にしたクリーンアーキテクチャの原則
- **単一責任の原則（Single Responsibility Principle）**
  - `entity`、`factory`共にエンティティの生成に必要なプロパティを持つように単一の責任を持たせるような設計にしました。
  - 例えば、`src/domain/factory/user/create_user.domain.entity.go`ファイルの場合、WithUserId、WithEmail、WithUserName、WithPasswordそれぞれが単一の責任を持ち、CreateUserFactoryPropsの特定のプロパティを設定もしくは制御するために使用されています。

- **ドメインの関心事の分離**
  - ドメインの関心事である、ユーザー作成に関連するロジックや、ユーザー情報を適切に抽出および整形するロジックを含んでいます。
  - 他の層の関心事（例えば、データベースへの保存やHTTPリクエストの処理）とは分離されています。

- **ドメインロジックの封装**
  - `entity`、`factory`のpropsに含まれている各オプション関数は、ドメインルールに基づいてプロパティを設定し、エラーメッセージを返すことができる。

- **エラーハンドリング**
  - `entity`、`factory`共に、エラーが発生した場合に適切なエラー処理が行われる。
  - エラーメッセージは、errors.ApiErrMessage型を使用して構造化され、適切なステータスコードとともに返されるような仕様となっています。
  - Inputのバリデーション(Bad Request)と区別するために、ドメイン層で想定されているエラーについては`Enable Check Error`と定義しています。(命名については必ずしも「Enable Check Error」である必要はないですが、ルールを設け統一しておくことを推奨します。)

- **テスト容易性**
  - `entity`、`factory`のオプション関数は、小さな単位で構成されており、単体テストを書きやすい構造になっています。
  - 各オプション関数は、独立してテスト可能であり、ファクトリー関数との組み合わせもテストしやすくなっています。

